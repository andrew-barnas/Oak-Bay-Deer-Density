SECR Models manuscript verison! The goals here are to make all the minor tweaks to the model that we can

Things I have added
1. Baseline model - July 11th 


```{r}
#Clear everything out, its probably messy from the data prep file
rm(list = ls())

#Packages we will need
library(reproducible) #setting up directories for data management
library(dplyr)        #data wranglin'
library(ggplot2)      #data visualization
library(ggpubr)       #Arranging figures
library(stringr)      #reading information on strings
library(secr)         #the actual model engine
library(ggtext)       #Superscript on ggplot axis title
library(sf)           #Spatial data

#Set the working directories to read in the files we need
input_directory<-reproducible::checkPath(file.path(getwd(), "2. SECR Prep/outputs"), create = TRUE)
output_directory<-reproducible::checkPath(file.path(getwd(), "3. SECR Models/outputs"), create = TRUE)
figure_directory<-reproducible::checkPath(file.path(getwd(), "3. SECR Models/figures"), create = TRUE)
shapefiles_directory<-reproducible::checkPath(file.path(getwd(), "3. SECR Models/shapefiles"), create = TRUE)



```

2018 Model
```{r}
start_time<-Sys.time()

#First create a capture history object using the above created text files. This is our base secr object
deer_secr_2018<-read.capthist(captfile = file.path(input_directory, "captures_2018.txt"), 
                         trapfile = file.path(input_directory, "deer_cameras_2018.txt"),
                         detector = "count", #this is a proximity detector (records presence at a point without restricting movement)
                         #but allows >1 detection per animal per time
                         markocc = rep(0,30), #This is a vector of n = number of occassions, all zeros indicate no marking done, this is ALL resighting data
                         skip = 1, #Skip = 1 says don't read the first row, which is the headers!
                         verify = TRUE) #Checks to make sure sampling occassions, effort, etc. all match up    
summary(deer_secr_2018)

#This shows a plot of detections for individuals
#Good to inspect that you dont have an individual located on traps on completely different 
#sides of the study area (unlikely, would indicate an error likely - unless the move A LOT)
png(file.path(figure_directory, "deer_secr_2018_tracks.jpeg"), width = 400, height = 600)
plot(deer_secr_2018, tracks = TRUE)
dev.off()

#Lets add the unmarked sightings to the capture history object
deer_secr_2018<-addSightings(deer_secr_2018, unmarked = file.path(input_directory, "unmarked_matrix_2018.txt"), skip = 1)
summary(deer_secr_2018)


#Next, read in the habitat mask we will be using, with an initial 1000m buffer
#oak_bay_clipped_2018<-st_read("3. SECR Models/shapefiles/new_cams_Buffer1_Erase.shp")
oak_bay_clipped_2018<-st_read(file.path(shapefiles_directory, "cameras_2018_clipped.shp"))
#Use that shape file to create a habitat mask for the initial model
mask_2018<-make.mask(traps(deer_secr_2018), 
                type = "trapbuffer", 
                buffer = 1000, 
                poly = oak_bay_clipped_2018)



#Fit the initial model
fit<-secr.fit(deer_secr_2018, 
              mask = mask_2018, #Specify the habitat mask
             # buffer = 1500,   #No need to specify a buffer here, since we have a mask
              detectfn = "HN", #Half normal detection function
              binomN = 0,      #Specify detections as a Poisson process
              trace = TRUE)

#Inspect the mask!
par(mar = c(1,1,1,1))
plot(fit$mask, dots = FALSE, mesh = "grey", col = "white")
plot(traps(deer_secr_2018), detpar = list(pch = 16, cex = 1), add = TRUE)



#Perform Retrospective buffer checks
#Pilot estimate for buffer width. 4* this value is a suggested buffer risk
RPSV_2018<-4*RPSV(deer_secr_2018, CC= TRUE)

#What is the suggested buffer from the initial fitted model
suggested_buffer_2018<-suggest.buffer(fit)

#Save the esa plot to a dataframe for plotting
A<-esa.plot(fit, ylim = c(0,10))

esa_plot_2018<-ggplot(A, aes(x = buffer, y = density))+
  geom_line()+
  geom_vline(aes(xintercept = RPSV_2018), color = "blue", linetype = "longdash")+
  geom_vline(aes(xintercept = suggested_buffer_2018), color = "firebrick3", linetype = "longdash")+
  annotate("text", x = RPSV_2018 + 40, y = 20, label = "4*RPSV")+
  annotate("text", x = suggested_buffer_2018 + 50, y = 20, label = "suggest.buffer")+
  ylab("Predicted change in density")+
  xlab("Buffer width (m)")+
  ggtitle("2018")+
  theme_classic()+
  theme(axis.title.x = element_text(size = 15),
        axis.title.y = element_text(size = 15),
        axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
         plot.title = element_text(size = 15, hjust = 0.5))

ggsave(filename = "esa_plot_2018.jpeg", #name of file
       plot = esa_plot_2018,                 #plot you want to save
       path = figure_directory,            #where it's saved
       width = 2500,                       #how wide
       height = 2500,                      #how tall
        units = "px",                      #units in pixels
        bg = 'white')                      #make sure background is white


#Based ont he recommendations of the guidebook, the penalty for using an over wie buffer is that fitting will be slower for a given mask spacing, it is usually smart to accept this penalty rather than search for the narrowest acceptabel buffer. 
buffer_2018<-suggest.buffer(fit)

#Create a new mask based on this
mask_2018<-make.mask(traps(deer_secr_2018), 
                type = "trapbuffer", 
                buffer = buffer_2018,
                poly = oak_bay_clipped_2018)



#What about overdispersion??
#1. fit the model ASSUMING NO OVERDISPERSION
#2. Estimate the overdispersion by simulating at the initial estimates
#3. Re-fit the model using an overdispersion-adjusted pseudo-likelioo
fit8_suggested_buffer <- secr.fit(deer_secr_2018, 
                                       mask = mask_2018,
                                       #buffer = 1000, 
                                       trace = FALSE, 
                                        detectfn = "HN", #Half normal detection function
                                        binomN = 0,      #Specify detections as a Poisson process
                                       start = fit, #this lines repeats the model specification from fit1
                       details = list(nsim = 10000)) #this line gives the previous model fit1 as a starting point, calls nsim simulations to estimated overdispersion (c-hat)

#Inspect the revised mask! Need to export this better. 
par(mar = c(1,1,1,1))
plot(fit8_suggested_buffer$mask, dots = FALSE, mesh = "grey", col = "white")
plot(traps(deer_secr_2018), detpar = list(pch = 16, cex = 1), add = TRUE)


#Extract estimate (deer/ha) and convert to deer per km2
fit8_mean<-(summary(fit8_suggested_buffer)[["predicted"]][["estimate"]][[1]]) *100
fit8_upper<-(summary(fit8_suggested_buffer)[["predicted"]][["ucl"]][[1]]) *100
fit8_lower<-(summary(fit8_suggested_buffer)[["predicted"]][["lcl"]][[1]]) *100



save(fit8_suggested_buffer, file = file.path(output_directory, "fit8_suggested_buffer.RData"))



```

2019 Model
```{r}
start_time<-Sys.time()

#First create a capture history object using the above created text files. This is our base secr object
deer_secr_2019<-read.capthist(captfile = file.path(input_directory, "captures_2019.txt"), 
                         trapfile = file.path(input_directory, "deer_cameras_2019.txt"),
                         detector = "count", #this is a proximity detector (records presence at a point without restricting movement)
                         #but allows >1 detection per animal per time
                         markocc = rep(0,35), #This is a vector of n = number of occassions, all zeros indicate no marking done, this is ALL resighting data
                         skip = 1, #Skip = 1 says don't read the first row, which is the headers!
                         verify = TRUE) #Checks to make sure sampling occassions, effort, etc. all match up    
summary(deer_secr_2019)

#This shows a plot of detections for individuals
#Good to inspect that you dont have an individual located on traps on completely different 
#sides of the study area (unlikely, would indicate an error likely - unless the move A LOT)
png(file.path(figure_directory, "deer_secr_2019_tracks.jpeg"), width = 400, height = 600)
plot(deer_secr_2019, tracks = TRUE)
dev.off()

#Lets add the unmarked sightings to the capture history object
deer_secr_2019<-addSightings(deer_secr_2019, unmarked = file.path(input_directory, "unmarked_matrix_2019.txt"), skip = 1)
summary(deer_secr_2019)


#Next, read in the habitat mask we will be using, with an initial 1000m buffer
oak_bay_clipped_2019<-st_read(file.path(shapefiles_directory, "cameras_2019_clipped.shp"))
#Use that shape file to create a habitat mask for the initial model
mask_2019<-make.mask(traps(deer_secr_2019), 
                type = "trapbuffer", 
                buffer = 1000, 
                poly = oak_bay_clipped_2019)



#Fit the initial model
fit<-secr.fit(deer_secr_2019, 
              mask = mask_2019, #Specify the habitat mask
             # buffer = 1500,   #No need to specify a buffer here, since we have a mask
              detectfn = "HN", #Half normal detection function
              binomN = 0,      #Specify detections as a Poisson process
              trace = TRUE)

#Inspect the mask!
par(mar = c(1,1,1,1))
plot(fit$mask, dots = FALSE, mesh = "grey", col = "white")
plot(traps(deer_secr_2019), detpar = list(pch = 16, cex = 1), add = TRUE)

browseURL("https://www.youtube.com/watch?v=NUYvbT6vTPs")


#Perform Retrospective buffer checks
#Pilot estimate for buffer width. 4* this value is a suggested buffer risk
RPSV_2019<-4*RPSV(deer_secr_2019, CC= TRUE)

#What is the suggested buffer from the initial fitted model
suggested_buffer_2019<-suggest.buffer(fit)

#Save the esa plot to a dataframe for plotting
A<-esa.plot(fit, ylim = c(0,10))

esa_plot_2019<-ggplot(A, aes(x = buffer, y = density))+
  geom_line()+
  geom_vline(aes(xintercept = RPSV_2019), color = "blue", linetype = "longdash")+
  geom_vline(aes(xintercept = suggested_buffer_2019), color = "firebrick3", linetype = "longdash")+
  annotate("text", x = RPSV_2019 -40, y = 40, label = "4*RPSV")+
  annotate("text", x = suggested_buffer_2019 + 70, y = 20, label = "suggest.buffer")+
  ylab("Predicted change in density")+
  xlab("Buffer width (m)")+
  ggtitle("2019")+
  theme_classic()+
  theme(axis.title.x = element_text(size = 15),
        axis.title.y = element_text(size = 15),
        axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
        plot.title = element_text(size = 15, hjust = 0.5))

ggsave(filename = "esa_plot_2019.jpeg", #name of file
       plot = esa_plot_2019,                 #plot you want to save
       path = figure_directory,            #where it's saved
       width = 2500,                       #how wide
       height = 2500,                      #how tall
        units = "px",                      #units in pixels
        bg = 'white')                      #make sure background is white


#Based ont he recommendations of the guidebook, the penalty for using an over wie buffer is that fitting will be slower for a given mask spacing, it is usually smart to accept this penalty rather than search for the narrowest acceptabel buffer. 
buffer_2019<-suggest.buffer(fit)

#Create a new mask based on this
mask_2019<-make.mask(traps(deer_secr_2019), 
                type = "trapbuffer", 
                buffer = buffer_2019,
                poly = oak_bay_clipped_2019)



#What about overdispersion??
#1. fit the model ASSUMING NO OVERDISPERSION
#2. Estimate the overdispersion by simulating at the initial estimates
#3. Re-fit the model using an overdispersion-adjusted pseudo-likelioo
fit2019_suggested_buffer <- secr.fit(deer_secr_2019, 
                                       mask = mask_2019,
                                       #buffer = 1000, 
                                       trace = FALSE, 
                                        detectfn = "HN", #Half normal detection function
                                        binomN = 0,      #Specify detections as a Poisson process
                                       start = fit, #this lines repeats the model specification from fit1
                       details = list(nsim = 10000)) #this line gives the previous model fit1 as a starting point, calls nsim simulations to estimated overdispersion (c-hat)

#Inspect the revised mask! Need to export this better. 
par(mar = c(1,1,1,1))
plot(fit2019_suggested_buffer$mask, dots = FALSE, mesh = "grey", col = "white")
plot(traps(deer_secr_2019), detpar = list(pch = 16, cex = 1), add = TRUE)


browseURL("https://www.youtube.com/watch?v=NUYvbT6vTPs")

#Extract estimate (deer/ha) and convert to deer per km2
fit2019_mean<-(summary(fit2019_suggested_buffer)[["predicted"]][["estimate"]][[1]]) *100
fit2019_upper<-(summary(fit2019_suggested_buffer)[["predicted"]][["ucl"]][[1]]) *100
fit2019_lower<-(summary(fit2019_suggested_buffer)[["predicted"]][["lcl"]][[1]]) *100



save(fit2019_suggested_buffer, file = file.path(output_directory, "fit2019_suggested_buffer.RData"))

```


2020 Model
```{r}
start_time<-Sys.time()

#First create a capture history object using the above created text files. This is our base secr object
deer_secr_2020<-read.capthist(captfile = file.path(input_directory, "captures_2020.txt"), 
                         trapfile = file.path(input_directory, "deer_cameras_2020.txt"),
                         detector = "count", #this is a proximity detector (records presence at a point without restricting movement)
                         #but allows >1 detection per animal per time
                         markocc = rep(0,35), #This is a vector of n = number of occassions, all zeros indicate no marking done, this is ALL resighting data
                         skip = 1, #Skip = 1 says don't read the first row, which is the headers!
                         verify = TRUE) #Checks to make sure sampling occassions, effort, etc. all match up    
summary(deer_secr_2020)

#This shows a plot of detections for individuals
#Good to inspect that you dont have an individual located on traps on completely different 
#sides of the study area (unlikely, would indicate an error likely - unless the move A LOT)
png(file.path(figure_directory, "deer_secr_2020_tracks.jpeg"), width = 400, height = 600)
plot(deer_secr_2020, tracks = TRUE)
dev.off()

#Lets add the unmarked sightings to the capture history object
deer_secr_2020<-addSightings(deer_secr_2020, unmarked = file.path(input_directory, "unmarked_matrix_2020.txt"), skip = 1)
summary(deer_secr_2020)


#Next, read in the habitat mask we will be using, with an initial 1000m buffer
oak_bay_clipped_2020<-st_read(file.path(shapefiles_directory, "cameras_2020_clipped.shp"))
#Use that shape file to create a habitat mask for the initial model
mask_2020<-make.mask(traps(deer_secr_2020), 
                type = "trapbuffer", 
                buffer = 1000, 
                poly = oak_bay_clipped_2020)



#Fit the initial model
fit<-secr.fit(deer_secr_2020, 
              mask = mask_2020, #Specify the habitat mask
             # buffer = 1500,   #No need to specify a buffer here, since we have a mask
              detectfn = "HN", #Half normal detection function
              binomN = 0,      #Specify detections as a Poisson process
              trace = TRUE)

#Inspect the mask!
par(mar = c(1,1,1,1))
plot(fit$mask, dots = FALSE, mesh = "grey", col = "white")
plot(traps(deer_secr_2020), detpar = list(pch = 16, cex = 1), add = TRUE)

browseURL("https://www.youtube.com/watch?v=NUYvbT6vTPs")


#Perform Retrospective buffer checks
#Pilot estimate for buffer width. 4* this value is a suggested buffer risk
RPSV_2020<-4*RPSV(deer_secr_2020, CC= TRUE)

#What is the suggested buffer from the initial fitted model
suggested_buffer_2020<-suggest.buffer(fit)

#Save the esa plot to a dataframe for plotting
A<-esa.plot(fit, ylim = c(0,10))

esa_plot_2020<-ggplot(A, aes(x = buffer, y = density))+
  geom_line()+
  geom_vline(aes(xintercept = RPSV_2020), color = "blue", linetype = "longdash")+
  geom_vline(aes(xintercept = suggested_buffer_2020), color = "firebrick3", linetype = "longdash")+
  annotate("text", x = RPSV_2020 -150, y = 40, label = "4*RPSV")+
  annotate("text", x = suggested_buffer_2020 + 200, y = 20, label = "suggest.buffer")+
  ylab("Predicted change in density")+
  xlab("Buffer width (m)")+
  ggtitle("2020")+
  theme_classic()+
  theme(axis.title.x = element_text(size = 15),
        axis.title.y = element_text(size = 15),
        axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
        plot.title = element_text(size = 15, hjust = 0.5))

ggsave(filename = "esa_plot_2020.jpeg", #name of file
       plot = esa_plot_2020,                 #plot you want to save
       path = figure_directory,            #where it's saved
       width = 2500,                       #how wide
       height = 2500,                      #how tall
        units = "px",                      #units in pixels
        bg = 'white')                      #make sure background is white


#Based ont he recommendations of the guidebook, the penalty for using an over wie buffer is that fitting will be slower for a given mask spacing, it is usually smart to accept this penalty rather than search for the narrowest acceptabel buffer. 
buffer_2020<-suggest.buffer(fit)

#Create a new mask based on this
mask_2020<-make.mask(traps(deer_secr_2020), 
                type = "trapbuffer", 
                buffer = buffer_2020,
                poly = oak_bay_clipped_2020)



#What about overdispersion??
#1. fit the model ASSUMING NO OVERDISPERSION
#2. Estimate the overdispersion by simulating at the initial estimates
#3. Re-fit the model using an overdispersion-adjusted pseudo-likelioo
fit2020_suggested_buffer <- secr.fit(deer_secr_2020, 
                                       mask = mask_2020,
                                       #buffer = 1000, 
                                       trace = FALSE, 
                                        detectfn = "HN", #Half normal detection function
                                        binomN = 0,      #Specify detections as a Poisson process
                                       start = fit, #this lines repeats the model specification from fit1
                       details = list(nsim = 10000)) #this line gives the previous model fit1 as a starting point, calls nsim simulations to estimated overdispersion (c-hat)

#Inspect the revised mask! Need to export this better. 
par(mar = c(1,1,1,1))
plot(fit2020_suggested_buffer$mask, dots = FALSE, mesh = "grey", col = "white")
plot(traps(deer_secr_2020), detpar = list(pch = 16, cex = 1), add = TRUE)


browseURL("https://www.youtube.com/watch?v=NUYvbT6vTPs")

#Extract estimate (deer/ha) and convert to deer per km2
fit2020_mean<-(summary(fit2020_suggested_buffer)[["predicted"]][["estimate"]][[1]]) *100
fit2020_upper<-(summary(fit2020_suggested_buffer)[["predicted"]][["ucl"]][[1]]) *100
fit2020_lower<-(summary(fit2020_suggested_buffer)[["predicted"]][["lcl"]][[1]]) *100



save(fit2020_suggested_buffer, file = file.path(output_directory, "fit2020_suggested_buffer.RData"))

```


2021 Model
```{r}
start_time<-Sys.time()

#First create a capture history object using the above created text files. This is our base secr object
deer_secr_2021<-read.capthist(captfile = file.path(input_directory, "captures_2021.txt"), 
                         trapfile = file.path(input_directory, "deer_cameras_2021.txt"),
                         detector = "count", #this is a proximity detector (records presence at a point without restricting movement)
                         #but allows >1 detection per animal per time
                         markocc = rep(0,30), #This is a vector of n = number of occassions, all zeros indicate no marking done, this is ALL resighting data
                         skip = 1, #Skip = 1 says don't read the first row, which is the headers!
                         verify = TRUE) #Checks to make sure sampling occassions, effort, etc. all match up    
summary(deer_secr_2021)

#This shows a plot of detections for individuals
#Good to inspect that you dont have an individual located on traps on completely different 
#sides of the study area (unlikely, would indicate an error likely - unless the move A LOT)
png(file.path(figure_directory, "deer_secr_2021_tracks.jpeg"), width = 400, height = 600)
plot(deer_secr_2021, tracks = TRUE)
dev.off()

#Lets add the unmarked sightings to the capture history object
deer_secr_2021<-addSightings(deer_secr_2021, unmarked = file.path(input_directory, "unmarked_matrix_2021.txt"), skip = 1)
summary(deer_secr_2021)


#Next, read in the habitat mask we will be using, with an initial 1000m buffer
oak_bay_clipped_2021<-st_read(file.path(shapefiles_directory, "cameras_2021_clipped.shp"))
#Use that shape file to create a habitat mask for the initial model
mask_2021<-make.mask(traps(deer_secr_2021), 
                type = "trapbuffer", 
                buffer = 1000, 
                poly = oak_bay_clipped_2021)



#Fit the initial model
fit<-secr.fit(deer_secr_2021, 
              mask = mask_2021, #Specify the habitat mask
             # buffer = 1500,   #No need to specify a buffer here, since we have a mask
              detectfn = "HN", #Half normal detection function
              binomN = 0,      #Specify detections as a Poisson process
              trace = TRUE)

#Inspect the mask!
par(mar = c(1,1,1,1))
plot(fit$mask, dots = FALSE, mesh = "grey", col = "white")
plot(traps(deer_secr_2021), detpar = list(pch = 16, cex = 1), add = TRUE)




#Perform Retrospective buffer checks
#Pilot estimate for buffer width. 4* this value is a suggested buffer risk
RPSV_2021<-4*RPSV(deer_secr_2021, CC= TRUE)

#What is the suggested buffer from the initial fitted model
suggested_buffer_2021<-suggest.buffer(fit)

#Save the esa plot to a dataframe for plotting
A<-esa.plot(fit, ylim = c(0,10))

esa_plot_2021<-ggplot(A, aes(x = buffer, y = density))+
  geom_line()+
  geom_vline(aes(xintercept = RPSV_2021), color = "blue", linetype = "longdash")+
  geom_vline(aes(xintercept = suggested_buffer_2021), color = "firebrick3", linetype = "longdash")+
  annotate("text", x = RPSV_2021 -60, y = 40, label = "4*RPSV")+
  annotate("text", x = suggested_buffer_2021 + 70, y = 20, label = "suggest.buffer")+
  ylab("Predicted change in density")+
  xlab("Buffer width (m)")+
  ggtitle("2021")+
  theme_classic()+
  theme(axis.title.x = element_text(size = 15),
        axis.title.y = element_text(size = 15),
        axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
        plot.title = element_text(size = 15, hjust = 0.5))

ggsave(filename = "esa_plot_2021.jpeg", #name of file
       plot = esa_plot_2021,                 #plot you want to save
       path = figure_directory,            #where it's saved
       width = 2500,                       #how wide
       height = 2500,                      #how tall
        units = "px",                      #units in pixels
        bg = 'white')                      #make sure background is white


#Based ont he recommendations of the guidebook, the penalty for using an over wie buffer is that fitting will be slower for a given mask spacing, it is usually smart to accept this penalty rather than search for the narrowest acceptabel buffer. 
buffer_2021<-suggest.buffer(fit)

#Create a new mask based on this
mask_2021<-make.mask(traps(deer_secr_2021), 
                type = "trapbuffer", 
                buffer = buffer_2021,
                poly = oak_bay_clipped_2021)



#What about overdispersion??
#1. fit the model ASSUMING NO OVERDISPERSION
#2. Estimate the overdispersion by simulating at the initial estimates
#3. Re-fit the model using an overdispersion-adjusted pseudo-likelioo
fit2021_suggested_buffer <- secr.fit(deer_secr_2021, 
                                       mask = mask_2021,
                                       #buffer = 1000, 
                                       trace = FALSE, 
                                        detectfn = "HN", #Half normal detection function
                                        binomN = 0,      #Specify detections as a Poisson process
                                       start = fit, #this lines repeats the model specification from fit1
                       details = list(nsim = 10000)) #this line gives the previous model fit1 as a starting point, calls nsim simulations to estimated overdispersion (c-hat)

#Inspect the revised mask! Need to export this better. 
par(mar = c(1,1,1,1))
plot(fit2021_suggested_buffer$mask, dots = FALSE, mesh = "grey", col = "white")
plot(traps(deer_secr_2021), detpar = list(pch = 16, cex = 1), add = TRUE)


browseURL("https://www.youtube.com/watch?v=NUYvbT6vTPs")

#Extract estimate (deer/ha) and convert to deer per km2
fit2021_mean<-(summary(fit2021_suggested_buffer)[["predicted"]][["estimate"]][[1]]) *100
fit2021_upper<-(summary(fit2021_suggested_buffer)[["predicted"]][["ucl"]][[1]]) *100
fit2021_lower<-(summary(fit2021_suggested_buffer)[["predicted"]][["lcl"]][[1]]) *100



save(fit2021_suggested_buffer, file = file.path(output_directory, "fit2021_suggested_buffer.RData"))

```




2022 Model
```{r}
start_time<-Sys.time()

#First create a capture history object using the above created text files. This is our base secr object
deer_secr_2022<-read.capthist(captfile = file.path(input_directory, "captures_2022.txt"), 
                         trapfile = file.path(input_directory, "deer_cameras_2022.txt"),
                         detector = "count", #this is a proximity detector (records presence at a point without restricting movement)
                         #but allows >1 detection per animal per time
                         markocc = rep(0,30), #This is a vector of n = number of occassions, all zeros indicate no marking done, this is ALL resighting data
                         skip = 1, #Skip = 1 says don't read the first row, which is the headers!
                         verify = TRUE) #Checks to make sure sampling occassions, effort, etc. all match up    
summary(deer_secr_2022)

#This shows a plot of detections for individuals
#Good to inspect that you dont have an individual located on traps on completely different 
#sides of the study area (unlikely, would indicate an error likely - unless the move A LOT)
png(file.path(figure_directory, "deer_secr_2022_tracks.jpeg"), width = 400, height = 600)
plot(deer_secr_2022, tracks = TRUE)
dev.off()

#Lets add the unmarked sightings to the capture history object
deer_secr_2022<-addSightings(deer_secr_2022, unmarked = file.path(input_directory, "unmarked_matrix_2022.txt"), skip = 1)
summary(deer_secr_2022)


#Next, read in the habitat mask we will be using, with an initial 1000m buffer
oak_bay_clipped_2022<-st_read(file.path(shapefiles_directory, "cameras_2022_clipped.shp"))
#Use that shape file to create a habitat mask for the initial model
mask_2022<-make.mask(traps(deer_secr_2022), 
                type = "trapbuffer", 
                buffer = 1000, 
                poly = oak_bay_clipped_2022)



#Fit the initial model
fit<-secr.fit(deer_secr_2022, 
              mask = mask_2022, #Specify the habitat mask
             # buffer = 1500,   #No need to specify a buffer here, since we have a mask
              detectfn = "HN", #Half normal detection function
              binomN = 0,      #Specify detections as a Poisson process
              trace = TRUE)

#Inspect the mask!
par(mar = c(1,1,1,1))
plot(fit$mask, dots = FALSE, mesh = "grey", col = "white")
plot(traps(deer_secr_2022), detpar = list(pch = 16, cex = 1), add = TRUE)



#Perform Retrospective buffer checks
#Pilot estimate for buffer width. 4* this value is a suggested buffer risk
RPSV_2022<-4*RPSV(deer_secr_2022, CC= TRUE)

#What is the suggested buffer from the initial fitted model
suggested_buffer_2022<-suggest.buffer(fit)

#Save the esa plot to a dataframe for plotting
A<-esa.plot(fit, ylim = c(0,10))

esa_plot_2022<-ggplot(A, aes(x = buffer, y = density))+
  geom_line()+
  geom_vline(aes(xintercept = RPSV_2022), color = "blue", linetype = "longdash")+
  geom_vline(aes(xintercept = suggested_buffer_2022), color = "firebrick3", linetype = "longdash")+
  annotate("text", x = RPSV_2022 -85, y = 40, label = "4*RPSV")+
  annotate("text", x = suggested_buffer_2022 + 200, y = 20, label = "suggest.buffer")+
  ylab("Predicted change in density")+
  xlab("Buffer width (m)")+
  theme_classic()+
  theme(axis.title.x = element_text(size = 15),
        axis.title.y = element_text(size = 15),
        axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
         plot.title = element_text(size = 15, hjust = 0.5))

ggsave(filename = "esa_plot_2022.jpeg", #name of file
       plot = esa_plot_2022,                 #plot you want to save
       path = figure_directory,            #where it's saved
       width = 2500,                       #how wide
       height = 2500,                      #how tall
        units = "px",                      #units in pixels
        bg = 'white')                      #make sure background is white


#Based ont he recommendations of the guidebook, the penalty for using an over wie buffer is that fitting will be slower for a given mask spacing, it is usually smart to accept this penalty rather than search for the narrowest acceptabel buffer. 
buffer_2022<-suggest.buffer(fit)

#Create a new mask based on this
mask_2022<-make.mask(traps(deer_secr_2022), 
                type = "trapbuffer", 
                buffer = buffer_2022,
                poly = oak_bay_clipped_2022)



#What about overdispersion??
#1. fit the model ASSUMING NO OVERDISPERSION
#2. Estimate the overdispersion by simulating at the initial estimates
#3. Re-fit the model using an overdispersion-adjusted pseudo-likelioo
fit2022_suggested_buffer <- secr.fit(deer_secr_2022, 
                                       mask = mask_2022,
                                       #buffer = 1000, 
                                       trace = FALSE, 
                                        detectfn = "HN", #Half normal detection function
                                        binomN = 0,      #Specify detections as a Poisson process
                                       start = fit, #this lines repeats the model specification from fit1
                       details = list(nsim = 10000)) #this line gives the previous model fit1 as a starting point, calls nsim simulations to estimated overdispersion (c-hat)

#Inspect the revised mask! Need to export this better. 
par(mar = c(1,1,1,1))
plot(fit2022_suggested_buffer$mask, dots = FALSE, mesh = "grey", col = "white")
plot(traps(deer_secr_2022), detpar = list(pch = 16, cex = 1), add = TRUE)


#Extract estimate (deer/ha) and convert to deer per km2
fit2022_mean<-(summary(fit2022_suggested_buffer)[["predicted"]][["estimate"]][[1]]) *100
fit2022_upper<-(summary(fit2022_suggested_buffer)[["predicted"]][["ucl"]][[1]]) *100
fit2022_lower<-(summary(fit2022_suggested_buffer)[["predicted"]][["lcl"]][[1]]) *100



save(fit2022_suggested_buffer, file = file.path(output_directory, "fit2022_suggested_buffer.RData"))

```

2023 Model
```{r}
start_time<-Sys.time()

#First create a capture history object using the above created text files. This is our base secr object
deer_secr_2023<-read.capthist(captfile = file.path(input_directory, "captures_2023.txt"), 
                         trapfile = file.path(input_directory, "deer_cameras_2023.txt"),
                         detector = "count", #this is a proximity detector (records presence at a point without restricting movement)
                         #but allows >1 detection per animal per time
                         markocc = rep(0,30), #This is a vector of n = number of occassions, all zeros indicate no marking done, this is ALL resighting data
                         skip = 1, #Skip = 1 says don't read the first row, which is the headers!
                         verify = TRUE) #Checks to make sure sampling occassions, effort, etc. all match up    
summary(deer_secr_2023)

#This shows a plot of detections for individuals
#Good to inspect that you dont have an individual located on traps on completely different 
#sides of the study area (unlikely, would indicate an error likely - unless the move A LOT)
png(file.path(figure_directory, "deer_secr_2023_tracks.jpeg"), width = 400, height = 600)
plot(deer_secr_2023, tracks = TRUE)
dev.off()

#Lets add the unmarked sightings to the capture history object
deer_secr_2023<-addSightings(deer_secr_2023, unmarked = file.path(input_directory, "unmarked_matrix_2023.txt"), skip = 1)
summary(deer_secr_2023)


#Next, read in the habitat mask we will be using, with an initial 1000m buffer
oak_bay_clipped_2023<-st_read(file.path(shapefiles_directory, "cameras_2023_clipped.shp"))
#Use that shape file to create a habitat mask for the initial model
mask_2023<-make.mask(traps(deer_secr_2023), 
                type = "trapbuffer", 
                buffer = 1000, 
                poly = oak_bay_clipped_2023)



#Fit the initial model
fit<-secr.fit(deer_secr_2023, 
              mask = mask_2023, #Specify the habitat mask
             # buffer = 1500,   #No need to specify a buffer here, since we have a mask
              detectfn = "HN", #Half normal detection function
              binomN = 0,      #Specify detections as a Poisson process
              trace = TRUE)

#Inspect the mask!
par(mar = c(1,1,1,1))
plot(fit$mask, dots = FALSE, mesh = "grey", col = "white")
plot(traps(deer_secr_2023), detpar = list(pch = 16, cex = 1), add = TRUE)



#Perform Retrospective buffer checks
#Pilot estimate for buffer width. 4* this value is a suggested buffer risk
RPSV_2023<-4*RPSV(deer_secr_2023, CC= TRUE)

#What is the suggested buffer from the initial fitted model
suggested_buffer_2023<-suggest.buffer(fit)

#Save the esa plot to a dataframe for plotting
A<-esa.plot(fit, ylim = c(0,10))

esa_plot_2023<-ggplot(A, aes(x = buffer, y = density))+
  geom_line()+
  geom_vline(aes(xintercept = RPSV_2023), color = "blue", linetype = "longdash")+
  geom_vline(aes(xintercept = suggested_buffer_2023), color = "firebrick3", linetype = "longdash")+
  annotate("text", x = RPSV_2023 -50, y = 40, label = "4*RPSV")+
  annotate("text", x = suggested_buffer_2023 + 60, y = 20, label = "suggest.buffer")+
  ylab("Predicted change in density")+
  xlab("Buffer width (m)")+
  theme_classic()+
  theme(axis.title.x = element_text(size = 15),
        axis.title.y = element_text(size = 15),
        axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
         plot.title = element_text(size = 15, hjust = 0.5))

ggsave(filename = "esa_plot_2023.jpeg", #name of file
       plot = esa_plot_2023,                 #plot you want to save
       path = figure_directory,            #where it's saved
       width = 2500,                       #how wide
       height = 2500,                      #how tall
        units = "px",                      #units in pixels
        bg = 'white')                      #make sure background is white


#Based ont he recommendations of the guidebook, the penalty for using an over wie buffer is that fitting will be slower for a given mask spacing, it is usually smart to accept this penalty rather than search for the narrowest acceptabel buffer. 
buffer_2023<-suggest.buffer(fit)

#Create a new mask based on this
mask_2023<-make.mask(traps(deer_secr_2023), 
                type = "trapbuffer", 
                buffer = buffer_2023,
                poly = oak_bay_clipped_2023)



#What about overdispersion??
#1. fit the model ASSUMING NO OVERDISPERSION
#2. Estimate the overdispersion by simulating at the initial estimates
#3. Re-fit the model using an overdispersion-adjusted pseudo-likelioo
fit2023_suggested_buffer <- secr.fit(deer_secr_2023, 
                                       mask = mask_2023,
                                       #buffer = 1000, 
                                       trace = FALSE, 
                                        detectfn = "HN", #Half normal detection function
                                        binomN = 0,      #Specify detections as a Poisson process
                                       start = fit, #this lines repeats the model specification from fit1
                       details = list(nsim = 10000)) #this line gives the previous model fit1 as a starting point, calls nsim simulations to estimated overdispersion (c-hat)

#Inspect the revised mask! Need to export this better. 
par(mar = c(1,1,1,1))
plot(fit2023_suggested_buffer$mask, dots = FALSE, mesh = "grey", col = "white")
plot(traps(deer_secr_2023), detpar = list(pch = 16, cex = 1), add = TRUE)


#Extract estimate (deer/ha) and convert to deer per km2
fit2023_mean<-(summary(fit2023_suggested_buffer)[["predicted"]][["estimate"]][[1]]) *100
fit2023_upper<-(summary(fit2023_suggested_buffer)[["predicted"]][["ucl"]][[1]]) *100
fit2023_lower<-(summary(fit2023_suggested_buffer)[["predicted"]][["lcl"]][[1]]) *100



save(fit2023_suggested_buffer, file = file.path(output_directory, "fit2023_suggested_buffer.RData"))


```

Final Figure
```{r}
#Load in the data we need
load(file.path(output_directory, "fit2018_suggested_buffer.RData"))
load(file.path(output_directory, "fit2019_suggested_buffer.RData"))
load(file.path(output_directory, "fit2020_suggested_buffer.RData"))
load(file.path(output_directory, "fit2021_suggested_buffer.RData"))
load(file.path(output_directory, "fit2022_suggested_buffer.RData"))
load(file.path(output_directory, "fit2023_suggested_buffer.RData"))


#Extract the estimates for each year and wrap them into a dataframe
#Extract estimate (deer/ha) and convert to deer per km2
mean_density_2018<-(summary(fit2018_suggested_buffer)[["predicted"]][["estimate"]][[1]]) *100
upper_density_CI_2018<-(summary(fit2018_suggested_buffer)[["predicted"]][["ucl"]][[1]]) *100
lower_density_CI_2018<-(summary(fit2018_suggested_buffer)[["predicted"]][["lcl"]][[1]]) *100

mean_density_2019<-(summary(fit2019_suggested_buffer)[["predicted"]][["estimate"]][[1]]) *100
upper_density_CI_2019<-(summary(fit2019_suggested_buffer)[["predicted"]][["ucl"]][[1]]) *100
lower_density_CI_2019<-(summary(fit2019_suggested_buffer)[["predicted"]][["lcl"]][[1]]) *100

mean_density_2020<-(summary(fit2020_suggested_buffer)[["predicted"]][["estimate"]][[1]]) *100
upper_density_CI_2020<-(summary(fit2020_suggested_buffer)[["predicted"]][["ucl"]][[1]]) *100
lower_density_CI_2020<-(summary(fit2020_suggested_buffer)[["predicted"]][["lcl"]][[1]]) *100


mean_density_2021<-(summary(fit2021_suggested_buffer)[["predicted"]][["estimate"]][[1]]) *100
upper_density_CI_2021<-(summary(fit2021_suggested_buffer)[["predicted"]][["ucl"]][[1]]) *100
lower_density_CI_2021<-(summary(fit2021_suggested_buffer)[["predicted"]][["lcl"]][[1]]) *100

mean_density_2022<-(summary(fit2022_suggested_buffer)[["predicted"]][["estimate"]][[1]]) *100
upper_density_CI_2022<-(summary(fit2022_suggested_buffer)[["predicted"]][["ucl"]][[1]]) *100
lower_density_CI_2022<-(summary(fit2022_suggested_buffer)[["predicted"]][["lcl"]][[1]]) *100

mean_density_2023<-(summary(fit2023_suggested_buffer)[["predicted"]][["estimate"]][[1]]) *100
upper_density_CI_2023<-(summary(fit2023_suggested_buffer)[["predicted"]][["ucl"]][[1]]) *100
lower_density_CI_2023<-(summary(fit2023_suggested_buffer)[["predicted"]][["lcl"]][[1]]) *100

density_estimates<-data.frame(year= c(2018, 2019, 2020, 2021, 2022, 2023),
                              mean_density = c(mean_density_2018, mean_density_2019, mean_density_2020, mean_density_2021, mean_density_2022, mean_density_2023),
           upper = c(upper_density_CI_2018, upper_density_CI_2019,  upper_density_CI_2020, upper_density_CI_2021, upper_density_CI_2022, upper_density_CI_2023),
           lower = c(lower_density_CI_2018, lower_density_CI_2019,  lower_density_CI_2020, lower_density_CI_2021, lower_density_CI_2022, lower_density_CI_2023))



ggplot(density_estimates, aes(x = as.factor(year), y = mean_density))+
  geom_point()+
  geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.2)+
  #ylab("Anthropogenic SO<sub>4</sub><sup>2-</sup> (ngm<sup>-3</sup>)")+
  ylab("Individuals<sup>-km2</sup> \u00B1 95% CI")+
  xlab("Year")+
  ggtitle("Preliminary Oak Bay Deer Density Estimates")+
  theme_classic()+
  theme(axis.text.y =element_text(size = 12, color = "black"),
        axis.title.y =element_markdown(size = 15, face = "bold", color = "black"),
        axis.text.x = element_text(size = 15, color = "black"),
         axis.title.x = element_blank())






```


###########################################################################################
########################SUPPLEMENTAL MATERIALS ############################################
###########################################################################################

Supplementary information on buffer sizes
```{r}

#Export the buffer information for each year
model_buffer_sizes<-data.frame(year= c(2018, 2019, 2020, 2021, 2022, 2023),
                              buffer_size = c(buffer_2018,
                              buffer_2019,
                              buffer_2020,
                              buffer_2021,
                              buffer_2022,
                              buffer_2023))

write.csv(model_buffer_sizes, file.path(output_directory, "model_buffer_sizes.csv"))


#Arrange the individual ESA buffer plots into a single pleasing figure
supplemental_buffer_plot<-ggpubr::ggarrange(esa_plot_2018, esa_plot_2019, esa_plot_2020, esa_plot_2021, esa_plot_2022, esa_plot_2023,
                  nrow = 3, ncol = 2,
                  labels = c("A", "B", "C", "D", "E", "F"))

ggsave(filename = "supplemental_buffer_plot.jpeg", #name of file
       plot = supplemental_buffer_plot,                 #plot you want to save
       path = figure_directory,            #where it's saved
       width = 4000,                       #how wide
       height = 4000,                      #how tall
        units = "px",                      #units in pixels
        bg = 'white')                      #make sure background is white

```

























